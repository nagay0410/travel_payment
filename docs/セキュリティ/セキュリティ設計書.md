# 旅行支払い精算アプリ セキュリティ設計書

## 1. 概要

### 1.1 目的
旅行支払い精算アプリのセキュリティ要件と実装方針を定義する

### 1.2 セキュリティ原則
- **Defense in Depth**: 多層防御によるセキュリティ確保
- **Principle of Least Privilege**: 最小権限の原則
- **Secure by Default**: デフォルトでセキュアな設定
- **Fail Securely**: 失敗時もセキュアな状態を維持
- **Security by Design**: 設計段階からのセキュリティ考慮

## 2. 脅威分析

### 2.1 主要な脅威

#### 2.1.1 認証・認可関連
- **認証バイパス**: 不正なログイン
- **権限昇格**: 不正な権限取得
- **セッションハイジャック**: セッションの乗っ取り
- **ブルートフォース攻撃**: パスワード推測

#### 2.1.2 データ関連
- **SQL インジェクション**: データベースへの不正アクセス
- **XSS（クロスサイトスクリプティング）**: 悪意のあるスクリプト実行
- **CSRF（クロスサイトリクエストフォージェリ）**: 不正なリクエスト送信
- **データ漏洩**: 機密情報の外部流出

#### 2.1.3 通信関連
- **中間者攻撃**: 通信の傍受・改ざん
- **リプレイ攻撃**: 通信の再送
- **DoS攻撃**: サービス拒否攻撃

### 2.2 リスク評価

| 脅威 | 発生確率 | 影響度 | リスクレベル | 対策優先度 |
|------|----------|--------|-------------|------------|
| 認証バイパス | 中 | 高 | 高 | 高 |
| SQL インジェクション | 低 | 高 | 中 | 高 |
| XSS | 中 | 中 | 中 | 中 |
| CSRF | 中 | 中 | 中 | 中 |
| データ漏洩 | 低 | 高 | 高 | 高 |
| 中間者攻撃 | 中 | 高 | 高 | 高 |

## 3. 認証・認可

### 3.1 認証方式

#### 3.1.1 JWT（JSON Web Token）
```csharp
public class JwtSettings
{
    public string SecretKey { get; set; }
    public string Issuer { get; set; }
    public string Audience { get; set; }
    public int ExpirationMinutes { get; set; }
    public int RefreshExpirationDays { get; set; }
    public int MaxRefreshTokenCount { get; set; } = 5;
}

public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;
    private readonly IUserSessionRepository _sessionRepository;
    
    public async Task<AuthResult> AuthenticateAsync(string email, string password)
    {
        // ユーザー認証
        var user = await _userRepository.GetByEmailAsync(email);
        if (user == null || !VerifyPassword(password, user.PasswordHash))
        {
            throw new AuthenticationException("メールアドレスまたはパスワードが正しくありません");
        }
        
        // アクセストークン生成
        var accessToken = GenerateAccessToken(user);
        
        // リフレッシュトークン生成
        var refreshToken = GenerateRefreshToken();
        
        // セッション保存
        await SaveUserSessionAsync(user.Id, refreshToken);
        
        return new AuthResult
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            ExpiresIn = _jwtSettings.ExpirationMinutes * 60,
            User = _mapper.Map<UserDto>(user)
        };
    }
    
    private string GenerateAccessToken(User user)
    {
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
            new Claim(JwtRegisteredClaimNames.Name, user.Username),
            new Claim(JwtRegisteredClaimNames.Email, user.Email),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim("user_id", user.Id.ToString())
        };
        
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
            signingCredentials: creds
        );
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

#### 3.1.2 パスワードセキュリティ
```csharp
public class PasswordService : IPasswordService
{
    private const int SaltSize = 16;
    private const int HashSize = 20;
    // OWASPの推奨に基づき、イテレーション回数は十分に高く設定する。
    // 例: 2023年時点でのPBKDF2の推奨値は310,000回以上。
    private const int Iterations = 310000;
    
    public string HashPassword(string password)
    {
        // .NET Core 2.0以降ではRandomNumberGenerator.Create()の使用が推奨される
        using (var rng = RandomNumberGenerator.Create())
        {
            byte[] salt = new byte[SaltSize];
            rng.GetBytes(salt);
            
            using (var pbkdf2 = new Rfc2898DeriveBytes(password, salt, Iterations, HashAlgorithmName.SHA256))
            {
                byte[] hash = pbkdf2.GetBytes(HashSize);
                
                byte[] hashBytes = new byte[SaltSize + HashSize];
                Array.Copy(salt, 0, hashBytes, 0, SaltSize);
                Array.Copy(hash, 0, hashBytes, SaltSize, HashSize);
                
                return Convert.ToBase64String(hashBytes);
            }
        }
    }
    
    public bool VerifyPassword(string password, string hashedPassword)
    {
        byte[] hashBytes = Convert.FromBase64String(hashedPassword);
        
        byte[] salt = new byte[SaltSize];
        Array.Copy(hashBytes, 0, salt, 0, SaltSize);
        
        using (var pbkdf2 = new Rfc2898DeriveBytes(password, salt, Iterations, HashAlgorithmName.SHA256))
        {
            byte[] hash = pbkdf2.GetBytes(HashSize);
            
            for (int i = 0; i < HashSize; i++)
            {
                if (hashBytes[i + SaltSize] != hash[i])
                    return false;
            }
            return true;
        }
    }
}
```

### 3.2 認可制御

#### 3.2.1 ロールベースアクセス制御（RBAC）
```csharp
public enum TripRole
{
    Admin,      // 管理者：旅行の編集・削除、メンバー管理
    Member,     // 一般参加者：支払い記録の作成・編集・削除
    Viewer      // 閲覧者：旅行情報の閲覧のみ
}

public class TripAuthorizationHandler : AuthorizationHandler<TripRequirement, Trip>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        TripRequirement requirement,
        Trip resource)
    {
        var userId = context.User.FindFirst("user_id")?.Value;
        if (string.IsNullOrEmpty(userId))
            return Task.CompletedTask;
            
        var member = resource.Members.FirstOrDefault(m => m.UserId.ToString() == userId);
        if (member == null)
            return Task.CompletedTask;
            
        // 権限チェック
        switch (requirement.Role)
        {
            case TripRole.Admin:
                if (member.Role == TripRole.Admin)
                    context.Succeed(requirement);
                break;
            case TripRole.Member:
                if (member.Role == TripRole.Admin || member.Role == TripRole.Member)
                    context.Succeed(requirement);
                break;
            case TripRole.Viewer:
                context.Succeed(requirement);
                break;
        }
        
        return Task.CompletedTask;
    }
}
```

#### 3.2.2 リソースベースアクセス制御
```csharp
public class ResourceAuthorizationHandler : AuthorizationHandler<ResourceRequirement, IResource>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        ResourceRequirement requirement,
        IResource resource)
    {
        var userId = context.User.FindFirst("user_id")?.Value;
        if (string.IsNullOrEmpty(userId))
            return Task.CompletedTask;
            
        // リソースの所有者または適切な権限を持つユーザーのみアクセス可能
        if (resource.OwnerId.ToString() == userId || 
            context.User.HasClaim("role", "Admin"))
        {
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}
```

## 4. データセキュリティ

### 4.1 データ暗号化

#### 4.1.1 保存時暗号化
```csharp
public class EncryptionService : IEncryptionService
{
    // 注意: 暗号化キーはAzure Key VaultやAWS KMSなどのシークレット管理サービスで安全に管理することを強く推奨します。
    // appsettings.jsonに平文で保存しないでください。
    private readonly byte[] _encryptionKey;
    
    public EncryptionService(IConfiguration configuration)
    {
        _encryptionKey = Convert.FromBase64String(configuration["Encryption:Key"]);
    }
    
    public string Encrypt(string plainText)
    {
        if (string.IsNullOrEmpty(plainText))
            return plainText;

        using (var aes = Aes.Create())
        {
            aes.Key = _encryptionKey;
            // IV (初期化ベクトル) は暗号化ごとにランダムに生成する必要があります。
            aes.GenerateIV();
            var iv = aes.IV;

            using (var encryptor = aes.CreateEncryptor(aes.Key, iv))
            using (var resultStream = new MemoryStream())
            {
                // IVを暗号文の先頭に書き込む
                resultStream.Write(iv, 0, iv.Length);
                using (var aesStream = new CryptoStream(resultStream, encryptor, CryptoStreamMode.Write))
                using (var plainStream = new MemoryStream(Encoding.UTF8.GetBytes(plainText)))
                {
                    plainStream.CopyTo(aesStream);
                }
                return Convert.ToBase64String(resultStream.ToArray());
            }
        }
    }
    
    public string Decrypt(string cipherText)
    {
        if (string.IsNullOrEmpty(cipherText))
            return cipherText;

        var fullCipher = Convert.FromBase64String(cipherText);

        using (var aes = Aes.Create())
        {
            // 暗号文の先頭からIVを読み取る
            var iv = new byte[aes.BlockSize / 8];
            var ciphertextBytes = new byte[fullCipher.Length - iv.Length];

            Array.Copy(fullCipher, 0, iv, 0, iv.Length);
            Array.Copy(fullCipher, iv.Length, ciphertextBytes, 0, ciphertextBytes.Length);

            aes.Key = _encryptionKey;
            aes.IV = iv;

            using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
            using (var cipherStream = new MemoryStream(ciphertextBytes))
            using (var cryptoStream = new CryptoStream(cipherStream, decryptor, CryptoStreamMode.Read))
            using (var reader = new StreamReader(cryptoStream, Encoding.UTF8))
            {
                return reader.ReadToEnd();
            }
        }
    }
}
```

#### 4.1.2 機密データの暗号化
```csharp
public class User : BaseEntity
{
    // 機密データは暗号化して保存
    private string _encryptedFirstName;
    private string _encryptedLastName;
    
    public string FirstName
    {
        get => _encryptionService.Decrypt(_encryptedFirstName);
        private set => _encryptedFirstName = _encryptionService.Encrypt(value);
    }
    
    public string LastName
    {
        get => _encryptionService.Decrypt(_encryptedLastName);
        private set => _encryptedLastName = _encryptionService.Encrypt(value);
    }
}
```

### 4.2 データ検証

#### 4.2.1 入力値検証
```csharp
public class CreateTripDtoValidator : AbstractValidator<CreateTripDto>
{
    public CreateTripDtoValidator()
    {
        RuleFor(x => x.TripName)
            .NotEmpty().WithMessage("旅行名は必須です")
            .MaximumLength(100).WithMessage("旅行名は100文字以内で入力してください")
            .Matches(@"^[a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\s\-_]+$")
            .WithMessage("旅行名に使用できない文字が含まれています");
            
        RuleFor(x => x.StartDate)
            .NotEmpty().WithMessage("開始日は必須です")
            .GreaterThan(DateTime.Today).WithMessage("開始日は今日より後の日付を選択してください");
            
        RuleFor(x => x.EndDate)
            .NotEmpty().WithMessage("終了日は必須です")
            .GreaterThan(x => x.StartDate).WithMessage("終了日は開始日より後の日付を選択してください");
            
        RuleFor(x => x.Budget)
            .GreaterThan(0).When(x => x.Budget.HasValue)
            .WithMessage("予算は0より大きい値を入力してください");
            
        RuleFor(x => x.MemberEmails)
            .Must(emails => emails == null || emails.All(IsValidEmail))
            .WithMessage("無効なメールアドレスが含まれています");
    }
    
    private bool IsValidEmail(string email)
    {
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }
}
```

#### 4.2.2 SQL インジェクション対策
```csharp
public class TripRepository : ITripRepository
{
    private readonly TravelPaymentDbContext _context;
    
    public async Task<IEnumerable<Trip>> SearchTripsAsync(string searchTerm, Guid userId)
    {
        // パラメータ化クエリでSQL インジェクションを防止
        return await _context.Trips
            .Include(t => t.Members)
            .Where(t => t.Members.Any(m => m.UserId == userId && m.IsActive))
            .Where(t => EF.Functions.Like(t.TripName, $"%{searchTerm}%") ||
                       EF.Functions.Like(t.Description, $"%{searchTerm}%"))
            .ToListAsync();
    }
}
```

## 5. 通信セキュリティ

### 5.1 HTTPS/TLS

#### 5.1.1 TLS設定
```csharp
public static class SecurityExtensions
{
    public static IServiceCollection AddSecurity(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddHsts(options =>
        {
            options.Preload = true;
            options.IncludeSubDomains = true;
            options.MaxAge = TimeSpan.FromDays(365);
        });
        
        services.AddHttpsRedirection(options =>
        {
            options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
            options.HttpsPort = 443;
        });
        
        return services;
    }
    
    public static IApplicationBuilder UseSecurity(this IApplicationBuilder app)
    {
        app.UseHsts();
        app.UseHttpsRedirection();
        
        // セキュリティヘッダーの設定
        app.Use(async (context, next) =>
        {
            context.Response.Headers.Add("X-Content-Type-Options", "nosniff");
            context.Response.Headers.Add("X-Frame-Options", "DENY");
            context.Response.Headers.Add("X-XSS-Protection", "1; mode=block");
            context.Response.Headers.Add("Referrer-Policy", "strict-origin-when-cross-origin");
            context.Response.Headers.Add("Content-Security-Policy", 
                "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self';");
            // 注意: 上記のCSPは一例です。実際のアプリケーションに合わせて調整が必要です。
            // 'unsafe-inline' はXSSのリスクがあるため、可能な限り避けるべきです。動的に生成されるスクリプトやスタイルが必要な場合は、nonceやhashを利用する方式を検討してください。
            
            await next();
        });
        
        return app;
    }
}
```

### 5.2 CORS設定

```csharp
public static class CorsExtensions
{
    public static IServiceCollection AddCorsPolicy(this IServiceCollection services, IConfiguration configuration)
    {
        var corsSettings = configuration.GetSection("Cors").Get<CorsSettings>();
        
        services.AddCors(options =>
        {
            options.AddPolicy("AllowedOrigins", policy =>
            {
                policy.WithOrigins(corsSettings.AllowedOrigins)
                      .WithMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                      .WithHeaders("Authorization", "Content-Type", "X-Requested-With")
                      .AllowCredentials()
                      .SetPreflightMaxAge(TimeSpan.FromMinutes(10));
            });
        });
        
        return services;
    }
}
```

## 6. セッション管理

### 6.1 セッションセキュリティ

```csharp
public class SessionService : ISessionService
{
    private readonly IUserSessionRepository _sessionRepository;
    private readonly ILogger<SessionService> _logger;
    
    public async Task<bool> ValidateSessionAsync(string refreshToken)
    {
        var session = await _sessionRepository.GetByRefreshTokenAsync(refreshToken);
        if (session == null)
            return false;
            
        // セッションの有効性チェック
        if (!session.IsActive || session.ExpiresAt < DateTime.UtcNow)
        {
            await DeactivateSessionAsync(session.SessionId);
            return false;
        }
        
        // 最終使用時刻を更新
        session.UpdateLastUsed();
        await _sessionRepository.UpdateAsync(session);
        
        return true;
    }
    
    public async Task DeactivateSessionAsync(Guid sessionId)
    {
        var session = await _sessionRepository.GetByIdAsync(sessionId);
        if (session != null)
        {
            session.Deactivate();
            await _sessionRepository.UpdateAsync(session);
            _logger.LogInformation("セッション {SessionId} が無効化されました", sessionId);
        }
    }
    
    public async Task DeactivateAllUserSessionsAsync(Guid userId)
    {
        var sessions = await _sessionRepository.GetByUserIdAsync(userId);
        foreach (var session in sessions)
        {
            session.Deactivate();
            await _sessionRepository.UpdateAsync(session);
        }
        _logger.LogInformation("ユーザー {UserId} の全セッションが無効化されました", userId);
    }
}
```

### 6.2 セッション固定化対策

```csharp
public class AuthenticationService : IAuthenticationService
{
    public async Task<AuthResult> LoginAsync(string email, string password)
    {
        // 既存のセッションを無効化（セッション固定化対策）
        var user = await _userRepository.GetByEmailAsync(email);
        if (user != null)
        {
            await _sessionService.DeactivateAllUserSessionsAsync(user.Id);
        }
        
        // 新しいセッションを作成
        // ... 認証処理
    }
}
```

## 7. 監査・ログ

### 7.1 セキュリティログ

```csharp
public class SecurityAuditService : ISecurityAuditService
{
    private readonly ILogger<SecurityAuditService> _logger;
    private readonly ISecurityAuditRepository _auditRepository;
    
    public async Task LogSecurityEventAsync(SecurityEvent securityEvent)
    {
        var audit = new SecurityAudit
        {
            EventType = securityEvent.EventType,
            UserId = securityEvent.UserId,
            IpAddress = securityEvent.IpAddress,
            UserAgent = securityEvent.UserAgent,
            Details = securityEvent.Details,
            Timestamp = DateTime.UtcNow
        };
        
        await _auditRepository.AddAsync(audit);
        
        // 重要なセキュリティイベントはログにも記録
        switch (securityEvent.EventType)
        {
            case SecurityEventType.LoginSuccess:
                _logger.LogInformation("ログイン成功: ユーザー {UserId} が {IpAddress} からログインしました", 
                    securityEvent.UserId, securityEvent.IpAddress);
                break;
            case SecurityEventType.LoginFailure:
                _logger.LogWarning("ログイン失敗: {IpAddress} からのログイン試行が失敗しました", 
                    securityEvent.IpAddress);
                break;
            case SecurityEventType.UnauthorizedAccess:
                _logger.LogWarning("不正アクセス: ユーザー {UserId} が {Resource} にアクセスしようとしました", 
                    securityEvent.UserId, securityEvent.Resource);
                break;
        }
    }
}
```

### 7.2 監査ログの種類

```csharp
public enum SecurityEventType
{
    LoginSuccess,           // ログイン成功
    LoginFailure,           // ログイン失敗
    Logout,                 // ログアウト
    PasswordChange,         // パスワード変更
    ProfileUpdate,          // プロフィール更新
    UnauthorizedAccess,     // 不正アクセス
    DataAccess,             // データアクセス
    DataModification,       // データ変更
    DataDeletion,           // データ削除
    SessionExpired,         // セッション期限切れ
    AccountLocked,          // アカウントロック
    AccountUnlocked         // アカウントアンロック
}
```

## 8. レート制限

### 8.1 API レート制限

```csharp
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDistributedCache _cache;
    private readonly ILogger<RateLimitingMiddleware> _logger;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var endpoint = context.GetEndpoint();
        var rateLimitAttribute = endpoint?.Metadata.GetMetadata<RateLimitAttribute>();
        
        if (rateLimitAttribute != null)
        {
            var clientId = GetClientId(context);
            var key = $"rate_limit:{clientId}:{endpoint.DisplayName}";
            
            var currentCount = await _cache.GetStringAsync(key);
            var count = currentCount == null ? 0 : int.Parse(currentCount);
            
            if (count >= rateLimitAttribute.MaxRequests)
            {
                _logger.LogWarning("レート制限に達しました: {ClientId} が {Endpoint} にアクセス", 
                    clientId, endpoint.DisplayName);
                    
                context.Response.StatusCode = 429; // Too Many Requests
                context.Response.ContentType = "application/json";
                
                var response = new
                {
                    success = false,
                    message = "リクエストが多すぎます。しばらく時間をおいてから再試行してください。",
                    retryAfter = rateLimitAttribute.WindowMinutes * 60
                };
                
                context.Response.Headers.Add("Retry-After", response.retryAfter.ToString());
                await context.Response.WriteAsJsonAsync(response);
                return;
            }
            
            await _cache.SetStringAsync(key, (count + 1).ToString(), 
                new DistributedCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(rateLimitAttribute.WindowMinutes)
                });
        }
        
        await _next(context);
    }
    
    private string GetClientId(HttpContext context)
    {
        // IPアドレスまたはユーザーIDをクライアント識別子として使用
        var userId = context.User.FindFirst("user_id")?.Value;
        if (!string.IsNullOrEmpty(userId))
            return $"user_{userId}";
            
        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }
}
```

### 8.2 レート制限属性

```csharp
[AttributeUsage(AttributeTargets.Method)]
public class RateLimitAttribute : Attribute
{
    public int MaxRequests { get; }
    public int WindowMinutes { get; }
    
    public RateLimitAttribute(int maxRequests, int windowMinutes = 1)
    {
        MaxRequests = maxRequests;
        WindowMinutes = windowMinutes;
    }
}

// 使用例
[HttpPost("login")]
[RateLimit(MaxRequests = 5, WindowMinutes = 1)]
public async Task<IActionResult> Login([FromBody] LoginDto dto)
{
    // ログイン処理
}
```

## 9. セキュリティテスト

### 9.1 セキュリティテスト計画

#### 9.1.1 静的解析
- **SonarQube**: コード品質・セキュリティ脆弱性の検出
- **OWASP Dependency Check**: 依存関係の脆弱性チェック
- **CodeQL**: GitHub のセキュリティ分析

#### 9.1.2 動的テスト
- **OWASP ZAP**: Web アプリケーションの脆弱性スキャン
- **Burp Suite**: 手動セキュリティテスト
- **Nessus**: ネットワーク・アプリケーション脆弱性スキャン

#### 9.1.3 ペネトレーションテスト
- **認証・認可テスト**: 権限昇格、認証バイパスの検証
- **入力値検証テスト**: SQL インジェクション、XSS の検証
- **セッション管理テスト**: セッションハイジャックの検証

### 9.2 セキュリティテストの実装

```csharp
[TestClass]
public class SecurityTests
{
    [TestMethod]
    public async Task Login_WithInvalidCredentials_ShouldNotRevealUserExistence()
    {
        // Arrange
        var client = CreateTestClient();
        var invalidCredentials = new LoginDto
        {
            Email = "nonexistent@example.com",
            Password = "wrongpassword"
        };
        
        // Act
        var response = await client.PostAsJsonAsync("/api/auth/login", invalidCredentials);
        
        // Assert
        Assert.AreEqual(HttpStatusCode.Unauthorized, response.StatusCode);
        
        var content = await response.Content.ReadAsStringAsync();
        var result = JsonSerializer.Deserialize<ErrorResponse>(content);
        
        // ユーザーの存在を明かさない
        Assert.AreEqual("メールアドレスまたはパスワードが正しくありません", result.Message);
    }
    
    [TestMethod]
    public async Task Trip_WithoutAuthentication_ShouldReturnUnauthorized()
    {
        // Arrange
        var client = CreateTestClient();
        
        // Act
        var response = await client.GetAsync("/api/trips");
        
        // Assert
        Assert.AreEqual(HttpStatusCode.Unauthorized, response.StatusCode);
    }
    
    [TestMethod]
    public async Task Trip_WithInsufficientPermissions_ShouldReturnForbidden()
    {
        // Arrange
        var client = CreateTestClient();
        var user = await CreateTestUserAsync();
        var token = await GetAuthTokenAsync(client, user);
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
        
        var trip = await CreateTestTripAsync(user.Id);
        var otherUser = await CreateTestUserAsync();
        var otherToken = await GetAuthTokenAsync(client, otherUser);
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", otherToken);
        
        // Act
        var response = await client.DeleteAsync($"/api/trips/{trip.Id}");
        
        // Assert
        Assert.AreEqual(HttpStatusCode.Forbidden, response.StatusCode);
    }
}
```

## 10. インシデント対応

### 10.1 セキュリティインシデント対応手順

#### 10.1.1 インシデント検出
- **自動検出**: セキュリティログの監視
- **手動検出**: ユーザーからの報告
- **外部検出**: セキュリティ研究者からの報告

#### 10.1.2 インシデント対応フロー
1. **検出・報告**: インシデントの検出と報告
2. **初期対応**: 影響範囲の特定と初期対応
3. **調査・分析**: 原因の特定と影響範囲の詳細分析
4. **対応・復旧**: 脆弱性の修正とシステムの復旧
5. **事後対応**: 再発防止策の実施とレポート作成

#### 10.1.3 緊急時連絡体制
- **開発チーム**: 技術的な対応
- **セキュリティチーム**: セキュリティ専門家
- **経営陣**: 重要な意思決定
- **外部連携**: 必要に応じて専門機関との連携

---

*このセキュリティ設計書は開発の進行に応じて更新される場合があります。*
