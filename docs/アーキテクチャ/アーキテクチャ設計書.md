# 旅行支払い精算アプリ アーキテクチャ設計書

## 1. 概要

### 1.1 目的
旅行支払い精算アプリのバックエンドアーキテクチャを定義する

### 1.2 設計原則
- **クリーンアーキテクチャ**: 依存関係の方向性を明確化
- **SOLID原則**: 保守性・拡張性の高い設計
- **セキュリティファースト**: 認証・認可を重視
- **パフォーマンス**: 高速なレスポンスを実現
- **スケーラビリティ**: 将来の拡張に対応

## 2. アーキテクチャパターン

### 2.1 クリーンアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   Controllers │  │   Middleware │  │   Filters & Attributes │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   Services   │  │   DTOs      │  │   Validators        │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    Domain Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   Entities   │  │   Interfaces │  │   Domain Services   │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                  Infrastructure Layer                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   Repositories │  │   Database   │  │   External Services │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 レイヤー間の依存関係
- Presentation Layer → Application Layer
- Application Layer → Domain Layer
- Infrastructure Layer → Domain Layer
- **禁止**: Domain Layer → Infrastructure Layer

## 3. プロジェクト構造

### 3.1 ソリューション構成

```
TravelPayment.sln
├── src/
│   ├── API/                 # Web API プロジェクト
│   ├── Application/         # アプリケーション層
│   ├── Domain/              # ドメイン層
│   ├── Infrastructure/      # インフラストラクチャ層
│   └── Shared/              # 共通ライブラリ
├── tests/
│   ├── API/                 # API テスト
│   ├── Application/         # アプリケーション層テスト
│   ├── Domain/              # ドメイン層テスト
│   └── Infrastructure/      # インフラ層テスト
└── docs/                    # ドキュメント
```

### 3.2 各プロジェクトの詳細

#### 3.2.1 TravelPayment.API
- **役割**: HTTP エンドポイントの提供
- **主要コンポーネント**:
  - Controllers
  - Middleware
  - Filters
  - Program.cs (設定・DI設定)

#### 3.2.2 TravelPayment.Application
- **役割**: ビジネスロジックの実装
- **主要コンポーネント**:
  - Services
  - DTOs
  - Validators
  - Mappers
  - Interfaces

#### 3.2.3 TravelPayment.Domain
- **役割**: ビジネスルールとエンティティの定義
- **主要コンポーネント**:
  - Entities
  - Value Objects
  - Domain Services
  - Interfaces
  - Exceptions

#### 3.2.4 TravelPayment.Infrastructure
- **役割**: 外部サービスとの連携
- **主要コンポーネント**:
  - Repositories
  - Database Context
  - External Services
  - Configuration

## 4. ドメインモデル

### 4.0 共通基底クラス

#### 4.0.1 BaseEntity
多くのエンティティで共通するプロパティ（ID、作成日時、更新日時）を管理するための基底クラスです。
```csharp
public abstract class BaseEntity
{
    public Guid Id { get; protected set; }
    public DateTime CreatedAt { get; protected set; }
    public DateTime UpdatedAt { get; protected set; }

    protected BaseEntity()
    {
        Id = Guid.NewGuid();
        CreatedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
    }
}
```

### 4.1 エンティティ

#### 4.1.1 User（ユーザー）
```csharp
public class User : BaseEntity
{
    public string Username { get; private set; }
    public string Email { get; private set; }
    public string PasswordHash { get; private set; }
    public string FirstName { get; private set; }
    public string LastName { get; private set; }
    public string ProfileImage { get; private set; }
    public bool IsActive { get; private set; }
    public bool EmailVerified { get; private set; }
    public DateTime? LastLoginAt { get; private set; }
    
    // ナビゲーションプロパティ
    public virtual ICollection<TripMember> TripMembers { get; private set; }
    public virtual ICollection<Payment> Payments { get; private set; }
    
    // ビジネスメソッド
    public void UpdateProfile(string firstName, string lastName, string profileImage)
    public void Deactivate()
    public void UpdateLastLogin()
}
```

#### 4.1.2 Trip（旅行）
```csharp
public class Trip : BaseEntity
{
    public string TripName { get; private set; }
    public string Description { get; private set; }
    public DateTime StartDate { get; private set; }
    public DateTime EndDate { get; private set; }
    public decimal? Budget { get; private set; }
    public TripStatus Status { get; private set; }
    public string CoverImage { get; private set; }
    public Guid CreatedById { get; private set; }
    
    // ナビゲーションプロパティ
    public virtual User CreatedBy { get; private set; }
    public virtual ICollection<TripMember> Members { get; private set; }
    public virtual ICollection<Payment> Payments { get; private set; }
    public virtual ICollection<Settlement> Settlements { get; private set; }
    
    // ビジネスメソッド
    public void UpdateStatus(TripStatus newStatus)
    public void AddMember(User user, TripRole role)
    public void RemoveMember(Guid userId)
    public decimal CalculateTotalPayments()
    public decimal CalculatePerPersonAmount()
}
```

#### 4.1.3 Payment（支払い）
```csharp
public class Payment : BaseEntity
{
    public Guid TripId { get; private set; }
    public Guid PaidById { get; private set; }
    public Guid CategoryId { get; private set; }
    public decimal Amount { get; private set; }
    public string Description { get; private set; }
    public DateTime PaymentDate { get; private set; }
    public string ReceiptImage { get; private set; }
    public string Location { get; private set; }
    public string Currency { get; private set; }
    public decimal? ExchangeRate { get; private set; }
    public bool IsReimbursed { get; private set; }
    
    // ナビゲーションプロパティ
    public virtual Trip Trip { get; private set; }
    public virtual User PaidBy { get; private set; }
    public virtual Category Category { get; private set; }
    
    // ビジネスメソッド
    public void UpdateAmount(decimal newAmount)
    public void MarkAsReimbursed()
    public decimal GetAmountInJPY()
}
```

### 4.2 値オブジェクト

#### 4.2.1 Money（金額）
```csharp
public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }
    
    public Money(decimal amount, string currency = "JPY")
    {
        if (amount < 0)
            throw new ArgumentException("金額は0以上である必要があります");
            
        Amount = amount;
        Currency = currency;
    }
    
    public Money ConvertTo(string targetCurrency, decimal exchangeRate)
    {
        if (Currency == targetCurrency)
            return this;
            
        return new Money(Amount * exchangeRate, targetCurrency);
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }
}
```

#### 4.2.2 DateRange（日付範囲）
```csharp
public class DateRange : ValueObject
{
    public DateTime StartDate { get; }
    public DateTime EndDate { get; }
    
    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (startDate >= endDate)
            throw new ArgumentException("開始日は終了日より前である必要があります");
            
        StartDate = startDate;
        EndDate = endDate;
    }
    
    public int GetDaysCount()
    {
        return (EndDate - StartDate).Days + 1;
    }
    
    public bool IsOverlapping(DateRange other)
    {
        return StartDate <= other.EndDate && EndDate >= other.StartDate;
    }
}
```

## 5. アプリケーションサービス

### 5.1 旅行管理サービス

```csharp
public interface ITripService
{
    Task<TripDto> CreateTripAsync(CreateTripDto dto, Guid userId);
    Task<TripDto> GetTripAsync(Guid tripId, Guid userId);
    Task<PagedResult<TripDto>> GetTripsAsync(TripQueryDto query, Guid userId);
    Task<TripDto> UpdateTripAsync(Guid tripId, UpdateTripDto dto, Guid userId);
    Task DeleteTripAsync(Guid tripId, Guid userId);
    Task AddMemberAsync(Guid tripId, AddMemberDto dto, Guid userId);
    Task RemoveMemberAsync(Guid tripId, Guid memberId, Guid userId);
}

public class TripService : ITripService
{
    private readonly ITripRepository _tripRepository;
    private readonly IUserRepository _userRepository;
    private readonly ITripMemberRepository _memberRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IMapper _mapper;
    
    public async Task<TripDto> CreateTripAsync(CreateTripDto dto, Guid userId)
    {
        // ビジネスルールの検証
        var user = await _userRepository.GetByIdAsync(userId);
        if (user == null)
            throw new NotFoundException("ユーザーが見つかりません");
            
        // 旅行の作成
        var trip = new Trip(
            dto.TripName,
            dto.Description,
            dto.StartDate,
            dto.EndDate,
            dto.Budget,
            userId
        );
        
        // 作成者を管理者として追加
        trip.AddMember(user, TripRole.Admin);
        
        // 他のメンバーを追加
        if (dto.MemberEmails?.Any() == true)
        {
            foreach (var email in dto.MemberEmails)
            {
                var member = await _userRepository.GetByEmailAsync(email);
                if (member != null)
                {
                    trip.AddMember(member, TripRole.Member);
                }
            }
        }
        
        _tripRepository.Add(trip);
        await _unitOfWork.SaveChangesAsync();
        
        return _mapper.Map<TripDto>(trip);
    }
}
```

### 5.2 支払い管理サービス

```csharp
public interface IPaymentService
{
    Task<PaymentDto> CreatePaymentAsync(CreatePaymentDto dto, Guid userId);
    Task<PaymentDto> UpdatePaymentAsync(Guid paymentId, UpdatePaymentDto dto, Guid userId);
    Task DeletePaymentAsync(Guid paymentId, Guid userId);
    Task<PagedResult<PaymentDto>> GetPaymentsAsync(PaymentQueryDto query, Guid userId);
}

public class PaymentService : IPaymentService
{
    private readonly IPaymentRepository _paymentRepository;
    private readonly ITripRepository _tripRepository;
    private readonly ICategoryRepository _categoryRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IMapper _mapper;
    
    public async Task<PaymentDto> CreatePaymentAsync(CreatePaymentDto dto, Guid userId)
    {
        // 旅行の存在確認と権限チェック
        var trip = await _tripRepository.GetByIdAsync(dto.TripId);
        if (trip == null)
            throw new NotFoundException("旅行が見つかりません");
            
        var member = trip.Members.FirstOrDefault(m => m.UserId == userId);
        if (member == null)
            throw new UnauthorizedException("この旅行に参加していません");
            
        // カテゴリの存在確認
        var category = await _categoryRepository.GetByIdAsync(dto.CategoryId);
        if (category == null)
            throw new NotFoundException("カテゴリが見つかりません");
            
        // 支払い記録の作成
        var payment = new Payment(
            dto.TripId,
            userId,
            dto.CategoryId,
            dto.Amount,
            dto.Description,
            dto.PaymentDate,
            dto.ReceiptImage,
            dto.Location
        );
        
        _paymentRepository.Add(payment);
        await _unitOfWork.SaveChangesAsync();
        
        return _mapper.Map<PaymentDto>(payment);
    }
}
```

## 6. リポジトリパターン

### 6.1 リポジトリインターフェース

```csharp
public interface IRepository<T> where T : BaseEntity
{
    Task<T> GetByIdAsync(Guid id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<PagedResult<T>> GetPagedAsync(int page, int pageSize);
    void Add(T entity);
    void Update(T entity);
    void Delete(T entity);
}

public interface ITripRepository : IRepository<Trip>
{
    Task<IEnumerable<Trip>> GetByUserIdAsync(Guid userId);
    Task<Trip> GetByIdWithMembersAsync(Guid id);
    Task<Trip> GetByIdWithPaymentsAsync(Guid id);
    Task<bool> ExistsAsync(Guid id);
}

public interface IPaymentRepository : IRepository<Payment>
{
    Task<IEnumerable<Payment>> GetByTripIdAsync(Guid tripId);
    Task<IEnumerable<Payment>> GetByUserIdAsync(Guid userId);
    Task<decimal> GetTotalAmountByTripIdAsync(Guid tripId);
}
```

### 6.2 リポジトリの実装

```csharp
public class TripRepository : ITripRepository
{
    private readonly TravelPaymentDbContext _context;
    
    public TripRepository(TravelPaymentDbContext context)
    {
        _context = context;
    }
    
    public async Task<Trip> GetByIdAsync(Guid id)
    {
        return await _context.Trips
            .FirstOrDefaultAsync(t => t.Id == id);
    }
    
    public async Task<Trip> GetByIdWithMembersAsync(Guid id)
    {
        return await _context.Trips
            .Include(t => t.Members)
                .ThenInclude(m => m.User)
            .FirstOrDefaultAsync(t => t.Id == id);
    }
    
    public async Task<IEnumerable<Trip>> GetByUserIdAsync(Guid userId)
    {
        return await _context.Trips
            .Include(t => t.Members)
            .Where(t => t.Members.Any(m => m.UserId == userId && m.IsActive))
            .ToListAsync();
    }
}
```

## 7. 認証・認可

### 7.1 JWT認証

```csharp
public class JwtSettings
{
    public string SecretKey { get; set; }
    public string Issuer { get; set; }
    public string Audience { get; set; }
    public int ExpirationMinutes { get; set; }
    public int RefreshExpirationDays { get; set; }
}

public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;
    
    public string GenerateToken(User user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Email, user.Email)
        };
        
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
            signingCredentials: creds
        );
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

### 7.2 認可ポリシー

```csharp
public static class Policies
{
    public const string TripAdmin = "TripAdmin";
    public const string TripMember = "TripMember";
    public const string TripViewer = "TripViewer";
}

public class TripAuthorizationHandler : AuthorizationHandler<TripRequirement, Trip>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        TripRequirement requirement,
        Trip resource)
    {
        var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (string.IsNullOrEmpty(userId))
            return Task.CompletedTask;
            
        var member = resource.Members.FirstOrDefault(m => m.UserId.ToString() == userId);
        if (member == null)
            return Task.CompletedTask;
            
        switch (requirement.Role)
        {
            case TripRole.Admin:
                if (member.Role == TripRole.Admin)
                    context.Succeed(requirement);
                break;
            case TripRole.Member:
                if (member.Role == TripRole.Admin || member.Role == TripRole.Member)
                    context.Succeed(requirement);
                break;
            case TripRole.Viewer:
                context.Succeed(requirement);
                break;
        }
        
        return Task.CompletedTask;
    }
}
```

## 8. 例外処理

### 8.1 カスタム例外

```csharp
public abstract class TravelPaymentException : Exception
{
    public string ErrorCode { get; }
    
    protected TravelPaymentException(string message, string errorCode) 
        : base(message)
    {
        ErrorCode = errorCode;
    }
}

public class NotFoundException : TravelPaymentException
{
    public NotFoundException(string message) 
        : base(message, "NOT_FOUND") { }
}

public class UnauthorizedException : TravelPaymentException
{
    public UnauthorizedException(string message) 
        : base(message, "UNAUTHORIZED") { }
}

public class ValidationException : TravelPaymentException
{
    public IDictionary<string, string[]> Errors { get; }
    
    public ValidationException(string message, IDictionary<string, string[]> errors) 
        : base(message, "VALIDATION_ERROR")
    {
        Errors = errors;
    }
}
```

### 8.2 グローバル例外ハンドラー

```csharp
public class GlobalExceptionHandler : IExceptionHandler
{
    private readonly ILogger<GlobalExceptionHandler> _logger;
    
    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext,
        Exception exception,
        CancellationToken cancellationToken)
    {
        _logger.LogError(exception, "未処理の例外が発生しました");
        
        var (statusCode, message, errors) = exception switch
        {
            NotFoundException => (StatusCodes.Status404NotFound, exception.Message, null),
            UnauthorizedException => (StatusCodes.Status401Unauthorized, exception.Message, null),
            ValidationException validationEx => (StatusCodes.Status422UnprocessableEntity, exception.Message, validationEx.Errors),
            _ => (StatusCodes.Status500InternalServerError, "内部サーバーエラーが発生しました", null)
        };
        
        var response = new
        {
            success = false,
            message = message,
            errors = errors,
            statusCode = statusCode
        };
        
        httpContext.Response.StatusCode = statusCode;
        httpContext.Response.ContentType = "application/json";
        
        await httpContext.Response.WriteAsJsonAsync(response, cancellationToken);
        
        return true;
    }
}
```

## 9. ログ・監視

### 9.1 ログ設定

```csharp
public static class LoggingExtensions
{
    public static IHostBuilder ConfigureLogging(this IHostBuilder builder)
    {
        return builder.ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.AddDebug();
            
            if (context.HostingEnvironment.IsDevelopment())
            {
                logging.AddConsole();
            }
            else
            {
                logging.AddApplicationInsights();
            }
        });
    }
}
```

### 9.2 パフォーマンス監視

```csharp
public class PerformanceMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<PerformanceMiddleware> _logger;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var sw = Stopwatch.StartNew();
        
        try
        {
            await _next(context);
        }
        finally
        {
            sw.Stop();
            var elapsed = sw.ElapsedMilliseconds;
            
            if (elapsed > 1000) // 1秒以上かかるリクエストを警告
            {
                _logger.LogWarning("遅いリクエスト: {Method} {Path} - {Elapsed}ms", 
                    context.Request.Method, context.Request.Path, elapsed);
            }
            
            _logger.LogInformation("リクエスト完了: {Method} {Path} - {Elapsed}ms", 
                context.Request.Method, context.Request.Path, elapsed);
        }
    }
}
```

## 10. 設定管理

### 10.1 appsettings.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=TravelPayment;Trusted_Connection=true;"
  },
  "JwtSettings": {
    "SecretKey": "your-secret-key-here",
    "Issuer": "TravelPayment",
    "Audience": "TravelPaymentUsers",
    "ExpirationMinutes": 60,
    "RefreshExpirationDays": 7
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Cors": {
    "AllowedOrigins": ["http://localhost:4200"]
  }
}
```

### 10.2 設定クラス

```csharp
public class DatabaseSettings
{
    public string DefaultConnection { get; set; }
    public int CommandTimeout { get; set; } = 30;
    public bool EnableRetryOnFailure { get; set; } = true;
    public int MaxRetryCount { get; set; } = 3;
}

public class CorsSettings
{
    public string[] AllowedOrigins { get; set; }
    public string[] AllowedMethods { get; set; }
    public string[] AllowedHeaders { get; set; }
    public bool AllowCredentials { get; set; }
}
```

## 11. 将来的な拡張性

### 11.1 ドメインイベントの導入
現在のアーキテクチャは、各サービスが自身の責務を遂行する上で完結しています。しかし、将来的に機能が複雑化し、一つのアクションが複数の関心事を引き起こす場合（例：旅行作成時に通知を送信する、アクティビティログを記録するなど）、ドメインイベントの導入が有効です。

#### 11.1.1 ドメインイベントとは
ドメイン内で発生した重要な出来事を表すオブジェクトです。イベントは発生した事実を記録するだけで、その後の処理はイベントハンドラーに委ねられます。

#### 11.1.2 実装例
```csharp
// Domain Layer
public class TripMemberAddedEvent : IDomainEvent // MediatRのINotificationなどを想定
{
    public Guid TripId { get; }
    public Guid UserId { get; }
    public TripMemberAddedEvent(Guid tripId, Guid userId)
    {
        TripId = tripId;
        UserId = userId;
    }
}

// Entity
public class Trip : BaseEntity
{
    private readonly List<IDomainEvent> _domainEvents = new();
    public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddMember(User user, TripRole role)
    {
        // ... メンバー追加ロジック ...
        
        _domainEvents.Add(new TripMemberAddedEvent(this.Id, user.Id));
    }
    
    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}
```

#### 11.1.3 メリット
- **関心事の分離**: ドメインロジックと、通知送信やロギングなどの横断的関心事を分離できます。
- **疎結合**: イベント発行者と購読者が互いに依存しなくなり、システムの結合度が低下します。
- **拡張性**: 新しい要件が発生した場合、新しいイベントハンドラーを追加するだけで対応できます。

このパターンは、MediatRなどのライブラリを使用することで容易に実装できます。


---

*このアーキテクチャ設計書は開発の進行に応じて更新される場合があります。*